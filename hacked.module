<?php
// $Id$

/**
 * @file
 * The Hacked! module, shows which project have been changed since download.
 *
 * We download the original project file, and hash all the files contained
 * within, then we hash our local copies and compare.
 * This module should never be used on a production server.
 */

define('HACKED_CACHE_TABLE', 'cache');

define('HACKED_STATUS_UNCHECKED', 1);
define('HACKED_STATUS_UNHACKED', 2);
define('HACKED_STATUS_HACKED', 3);
define('HACKED_STATUS_DELETED', 4);

/**
 * Implementation of hook_menu().
 */
function hacked_menu() {
  $items = array();

  $items['admin/reports/hacked'] = array(
    'title' => 'Hacked',
    'description' => 'Get a code hacking report about your installed modules and themes.',
    'page callback' => 'hacked_reports_hacked',
    'access arguments' => array('administer site configuration'),
    'weight' => 10,
  );

  $items['admin/reports/hacked/%hacked_project'] = array(
    'title' => 'Hacked',
    'page callback' => 'hacked_reports_hacked_details',
    'page arguments' => array(3),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/reports/hacked/%hacked_project/diff/%hacked_tail'] = array(
    'title' => 'Hacked',
    'load arguments'   => array('%map', '%index'),
    'page callback' => 'hacked_reports_hacked_diff',
    'page arguments' => array(3, 5),
    'access arguments' => array('view diffs of changed files'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Helper to load the menu tail properly.
 *
 * Specifed as %hacked_tail in a menu path, this will return the entirety
 * of the the rest of the menu path.
 */
function hacked_tail_load($arg, $map, $index) {
  return implode('/', array_slice($map, $index));
}

/**
 * Menu loader for loading a project from its short name.
 *
 * In this function we call the calculate function both the update module and
 * our hacked module. This may mean we return FALSE when there is no internet
 * connection.
 *
 * @param $short_name The short name of the project to load.
 */
function hacked_project_load($short_name) {
  $available = update_get_available();
  $data = update_calculate_project_data($available);
  foreach ($data as $key => $project) {
    if ($project['short_name'] == $short_name) {
      $data_truncated = array($key => $project);
      $data_truncated = hacked_calculate_project_data($data_truncated);
      return $data_truncated[$key];
    }
  }
  return FALSE;
}

/**
 * Implementation of the hook_theme() registry.
 */
function hacked_theme() {
  return array(
    'hacked_report' => array(
      'arguments' => array('data' => NULL),
    ),
    'hacked_detailed_report' => array(
      'arguments' => array('data' => NULL),
    ),
  );
}

/**
 * Implementation of hook_perm().
 */
function hacked_perm() {
  return array(
    'view diffs of changed files',
  );
}

function hacked_reports_hacked_diff($project, $file) {

  // Find a better way to do this:
  $breadcrumb = array(
    l('Home', '<front>'),
    l('Administer', 'admin'),
    l('Reports', 'admin/reports'),
    l('Hacked', 'admin/reports/hacked'),
    l($project['title'], 'admin/reports/hacked/' . $project['short_name']),
  );
  drupal_set_breadcrumb($breadcrumb);

  $local_file = hacked_find_local_project_directory($project) . '/' . $file;
  $this_release = $project['releases'][$project['existing_version']];

  // Let's see if there's a download link:
  $dir = hacked_download_release($this_release['download_link'], $project['project_type'], $project['short_name'], $project['existing_version']);


  // Special handling for core:
  if ($project['project_type'] == 'core') {
    $original_file = $dir . '/' . $project['short_name'] . '-' . $project['existing_version'] . '/' . $file;
  }
  else {
    $original_file = $dir . '/' . $project['short_name'] . '/' . $file;
  }

  if (!hacked_file_is_binary($original_file) && !hacked_file_is_binary($local_file)) {
    return hacked_diff_changed($local_file, $original_file);
  }
  //
  return t('Cannot hash binary file or file not found: %file', array('%file' => $file));
}

function hacked_reports_hacked_details($project) {
  $short_name = $project['short_name'];
  $projects = hacked_calculate_project_data(array($short_name => $project));

  // Sort the results:
  arsort($projects[$short_name]['hacked_results']);


  // Send the results to the theme function:
  $out = theme('hacked_detailed_report', $projects);



  return $out;
}

function hacked_reports_hacked() {
  // We're going to be borrowing heavily from the update module
  module_load_include('inc', 'update', 'update.report');
  if ($available = update_get_available(TRUE)) {
    module_load_include('inc', 'update', 'update.compare');
    $data = update_calculate_project_data($available);
    $data = hacked_calculate_project_data($data);
    return theme('hacked_report', $data);
  }
  else {
    return theme('update_report', _update_no_data());
  }

}

function hacked_process_module($project) {
  hacked_hash_project($project);
}

function hacked_calculate_project_data($projects) {
  foreach ($projects as $project_key => $project) {
    if ($project['install_type'] == 'official') {
      $projects[$project_key]['hacked_status'] = HACKED_STATUS_UNCHECKED;
      // Go get the hashes of the clean copy of the installed version:
      $projects[$project_key]['clean_hashes'] = hacked_hash_project($project);
      // If we got some hashes, let's compare it with the local copy:
      if ($projects[$project_key]['clean_hashes']) {
        hacked_hash_local($projects[$project_key]);
        $hacked_count = 0;
        $deleted_count = 0;

        // Now do the comparison:
        foreach ($projects[$project_key]['clean_hashes'] as $file => $hash) {
          // Has the file been deleted:
          if (!isset($projects[$project_key]['local_hashes'][$file])) {
            $deleted_count++;
            $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_DELETED;
          }
          else {
            // We have the file, so has it been changed:
            if ($projects[$project_key]['local_hashes'][$file] != $hash) {
              $hacked_count++;
              $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_HACKED;
            }
            else {
              $projects[$project_key]['hacked_results'][$file] = HACKED_STATUS_UNHACKED;
            }
          }
        }

        // Record aggregate stats
        $projects[$project_key]['changed_count'] = $hacked_count;
        $projects[$project_key]['deleted_count'] = $deleted_count;
        if ($hacked_count) {
          $projects[$project_key]['hacked_status'] = HACKED_STATUS_HACKED;
        }
        else {
          $projects[$project_key]['hacked_status'] = HACKED_STATUS_UNHACKED;
        }
      }



    }
  }


  return $projects;
}

function hacked_hash_project($project) {
  if (($project['project_type'] == 'module') || ($project['project_type'] == 'theme') || ($project['project_type'] == 'core')) {
    if (isset($project['existing_version']) && isset($project['releases'][$project['existing_version']])) {
      $this_release = $project['releases'][$project['existing_version']];

      // Let's see if there's a download link:
      $dir = hacked_download_release($this_release['download_link'], $project['project_type'], $project['short_name'], $project['existing_version']);
      // Now hash that dir:
      $hashed = hacked_release_generate_hashes_cached($project['project_type'], $project['short_name'], $project['existing_version']);
      return $hashed;


    }
  }
}

function hacked_hash_local(&$project) {
  // Are there other types of project we should handle?
  if (($project['project_type'] == 'module')  || ($project['project_type'] == 'theme')|| ($project['project_type'] == 'core')) {
    if ($dir = hacked_find_local_project_directory($project)) {
      $project['local_hashes'] = hacked_scan_directory_generate_hashes($dir);
    }
    else {
      $project['local_hashes'] = array();
    }
  }
}

/**
 * Return the location of the installed project.
 *
 * As drupal modules do not need to be named the same as the projects they are
 * part of we need to be a little smarter about how we find the project
 * directory to start hashing in.
 */
function hacked_find_local_project_directory($project) {
  // Do we have at least some modules to check for:
  if (!is_array($project['includes']) || !count($project['includes'])) {
    return FALSE;
  }

  // If this project is drupal it, we need to handle it specially
  if ($project['project_type'] != 'core') {
    $include = array_shift(array_keys($project['includes']));
    $include_type = $project['project_type'];
  }
  else {
    // Just use the system module to find where we've installed drupal
    $include = 'system';
    $include_type = 'module';
  }

  $path = drupal_get_path($include_type, $include);

  // Now we need to find the path of the info file in the downloaded package:
  $temp = '';
  foreach ($project['clean_hashes'] as $file => $hash) {
    if (strpos($file, "$include.info") !== FALSE) {
      // TODO: Replace this with a regular expression
      $temp = str_replace("$include.info", '', $file);
      break;
    }
  }

  // How many '/' were in that path:
  $slash_count = substr_count($temp, '/');
  $back_track = str_repeat('/..', $slash_count);
  return realpath($path . $back_track);

}

/**
 * A standard method of forming the path name of the local copy of a project
 */
function hacked_release_form_path_name($type, $name, $version) {
  $dir = file_directory_temp() . "/hacked-cache/$type/$name";
  // Build the destination folder tree if it doesn't already exists.
  if (!file_check_directory($dir, FILE_CREATE_DIRECTORY) && !mkdir($dir, 0775, TRUE)) {
    watchdog('hacked', 'Failed to create temp directory: %dir', array('%dir' => $dir), WATCHDOG_ERROR);
    return FALSE;
  }
  return file_create_path(file_directory_temp() . "/hacked-cache/$type/$name/$version");
}

function hacked_download_release($release_url, $type, $short_name, $version) {

  // Compute the path where we'll store this release:
  $dir = hacked_release_form_path_name($type, $short_name, $version);


  // If our directory already exists, we can just return the path to this cached version
  if (file_exists($dir)) {
    return $dir;
  }

  // We've not downloaded this release before:
  // Let's try to download it:
  $request = drupal_http_request($release_url);

  // If we downloaded it, try to unpack it:
  if ($request->code == 200) {

    // Build the destination folder tree if it doesn't already exists.
    if (!file_check_directory($dir, FILE_CREATE_DIRECTORY) && !mkdir($dir, 0775, TRUE)) {
      watchdog('hacked', 'Failed to create temp directory: %dir', array('%dir' => $dir), WATCHDOG_ERROR);
      return FALSE;
    }

    // Save the tarball someplace:
    $project_path = file_create_path($dir . '/' . basename($release_url));
    file_save_data($request->data, $project_path);
    shell_exec("cd $dir; tar -zxf ". basename($project_path));
    file_delete($project_path);
    // If we unpacked it, return the path:

    return $dir;

  }

  // Something went wrong:
  return FALSE;
}

function hacked_release_generate_hashes($type, $short_name, $version) {
  $dir = hacked_release_form_path_name($type, $short_name, $version);


  // More special handling for core:
  if ($type != 'core') {
    $module_dir = $dir . "/$short_name";
  }
  else {
    $module_dir = $dir . "/$short_name-$version";
  }

  // Scan the directory for files:
  $hashes = hacked_scan_directory_generate_hashes($module_dir);
  return $hashes;
}

function hacked_release_generate_hashes_cached($type, $short_name, $version) {
  static $cached;
  if (is_null($cached)) {
    $cached = array();
  }

  // Return from the static cache if we can:
  if (isset($cached[$type][$short_name][$version])) {
    return $cached[$type][$short_name][$version];
  }

  // Return form the cache system if we can:
  $key = "hacked:hashes:$type:$short_name:$version";
  $cache = cache_get($key, HACKED_CACHE_TABLE);
  if ($cache && isset($cache->data)) {
    return $cache->data;
  }

  // Otherwise pass through to the actual function:
  $cached[$type][$short_name][$version] = hacked_release_generate_hashes($type, $short_name, $version);

  // Save into the cache table:
  cache_set($key, $cached[$type][$short_name][$version], HACKED_CACHE_TABLE);

  // Return the hashes:
  return $cached[$type][$short_name][$version];
}

function hacked_scan_directory_generate_hashes($directory) {
  $hashes = array();
  $files = file_scan_directory($directory, '.*');
  foreach ($files as $file) {
    $filename = str_replace($directory . '/', '', $file->filename);
    $hashes[$filename] = sha1_file($file->filename);
  }
  return $hashes;
}

function hacked_diff_changed($installed_file, $original_file) {
  // Load up the two files and diff them:
  module_load_include('php', 'diff', 'DiffEngine');
  $formatter = new DrupalDiffFormatter();

  $original_array = file_exists($original_file) ? file($original_file) : array();
  $installed_array = file_exists($installed_file) ? file($installed_file) : array();

  $diff = new Diff($original_array, $installed_array);
  $output = theme('diff_table', array(t('Orignal'), '', t('Current'), ''), $formatter->format($diff), array('class' => 'diff hacked-diff'));
  return $output;

}

/**
 * Recursively delete all files and folders in the specified filepath, then
 * delete the containing folder.
 *
 * Note that this only deletes visible files with write permission.
 *
 * @param string $path
 *   A filepath relative to file_directory_path.
 */
function _hacked_recursive_delete($path) {
  if (is_file($path) || is_link($path)) {
    unlink($path);
  }
  elseif (is_dir($path)) {
    $d = dir($path);
    while (($entry = $d->read()) !== FALSE) {
      if ($entry == '.' || $entry == '..') continue;
      $entry_path = $path . '/' . $entry;
      _hacked_recursive_delete($entry_path);
    }
    $d->close();
    rmdir($path);
  }
  else {
    watchdog('hacked', 'Unknown file type(%path) stat: %stat ',
              array('%path' => $path,  '%stat' => print_r(stat($path), 1)), WATCHDOG_ERROR);
  }

}

function hacked_file_is_binary($file) {
  if (file_exists($file)) {
    if (!is_file($file)) return 0;

    $fh  = fopen($file, "r");
    $blk = fread($fh, 512);
    fclose($fh);
    clearstatcache();

    return (
      0 or substr_count($blk, "^ -~", "^\r\n")/512 > 0.3
        or substr_count($blk, "\x00") > 0
    );
  }
  return 0;
}

/**
 * Theme project status report.
 *
 * @ingroup themeable
 */
function theme_hacked_detailed_report($projects) {
  foreach ($projects as $project) {
    foreach ($project['hacked_results'] as $file => $status) {
      switch ($status) {
        case HACKED_STATUS_UNHACKED:
          $class = 'ok';
          $icon = theme('image', 'misc/watchdog-ok.png', t('Unchanged'), t('Unchanged'));
          break;
        case HACKED_STATUS_DELETED:
          $class = 'error';
          $icon = theme('image', 'misc/watchdog-error.png', t('Changed'), t('Changed'));
          break;
        case HACKED_STATUS_HACKED:
          $class = 'warning';
          $icon = theme('image', 'misc/watchdog-warning.png', t('Deleted'), t('Deleted'));
          break;
        case HACKED_STATUS_UNCHECKED:
        default:
          $class = 'warning';
          $icon = theme('image', 'misc/watchdog-warning.png', t('Unchecked'), t('Unchecked'));
          break;
      }

      $row = '<div class="version-status">';
      switch ($status) {
        case HACKED_STATUS_UNHACKED:
          $row .= t('Unchanged');
          break;
        case HACKED_STATUS_HACKED:
          $row .= '<span class="not-current">' . t('Changed!') . '</span>';
          break;
        case HACKED_STATUS_DELETED:
          $row .= '<span class="">' . t('Deleted') . '</span>';
          break;
        case HACKED_STATUS_UNCHECKED:
        default:
          $row .= '<span class="">' . t('Unchecked') . '</span>';
          break;
      }
      $row .= '<span class="icon">' . $icon . '</span>';
      $row .= "</div>\n";

      $row .= '<div class="project">';
      if (user_access('view diffs of changed files') && module_exists('diff') && !hacked_file_is_binary(hacked_find_local_project_directory($project) . '/' . $file)) {
        $row .= l($file, 'admin/reports/hacked/' . $project['short_name'] . '/diff/' . $file);
      }
      else {
        $row .= check_plain($file);
      }
      $row .= "</div>\n";

      $row .= "</div>\n";

      $rows[] = array(
        'class' => $class,
        'data' => array($row),
      );
    }
    drupal_add_css(drupal_get_path('module', 'update') . '/update.css');
    return theme('table', NULL, $rows, array('class' => 'update'));
  }
  return 'here';
}

/**
 * Theme project status report.
 *
 * @ingroup themeable
 */
function theme_hacked_report($data) {
  $output = '';

  if (!is_array($data)) {
    $output .= '<p>' . $data . '</p>';
    return $output;
  }

  $header = array();
  $rows = array();

  foreach ($data as $project) {
    if (!isset($project['hacked_status'])) {
      continue;
    }

    switch ($project['hacked_status']) {
      case HACKED_STATUS_UNHACKED:
        $class = 'ok';
        $icon = theme('image', 'misc/watchdog-ok.png', t('Unchanged'), t('Unchanged'));
        break;
      case HACKED_STATUS_HACKED:
        $class = 'error';
        $icon = theme('image', 'misc/watchdog-error.png', t('Changed'), t('Changed'));
        break;
      case HACKED_STATUS_UNCHECKED:
      default:
        $class = 'warning';
        $icon = theme('image', 'misc/watchdog-warning.png', t('Unchecked'), t('Unchecked'));
        break;
    }

    $row = '<div class="version-status">';
    switch ($project['hacked_status']) {
      case HACKED_STATUS_UNHACKED:
        $row .= t('Unchanged');
        break;
      case HACKED_STATUS_HACKED:
        $row .= '<span class="not-current">' . t('Changed!') . '</span>';
        break;
      case HACKED_STATUS_UNCHECKED:
      default:
        $row .= '<span class="">' . t('Unchecked') . '</span>';
        break;
    }
    $row .= '<span class="icon">' . $icon . '</span>';
    $row .= "</div>\n";

    $row .= '<div class="project">';
    if (isset($project['title'])) {
      if (isset($project['link'])) {
        $row .= l($project['title'], $project['link']);
      }
      else {
        $row .= check_plain($project['title']);
      }
    }
    else {
      $row .= check_plain($project['name']);
    }
    $row .= ' ' . check_plain($project['existing_version']);
    if ($project['install_type'] == 'dev' && !empty($project['datestamp'])) {
      $row .= ' <span class="version-date">(' . format_date($project['datestamp'], 'custom', 'Y-M-d') . ')</span>';
    }
    $row .= "</div>\n";


    $row .= "<div class=\"versions\">\n";
    $row .= '<table class="version version-latest">';
    $row .= '<tr>';
    $row .= '<td class="version-title">'. format_plural($project['changed_count'], '1 file changed', '@count files changed') . ', ' . format_plural($project['deleted_count'], '1 file deleted', '@count files deleted') ."</td>\n";
    $row .= '</tr>';
    $row .= '</table>';
    $row .= '<table class="version version-latest">';
    $row .= '<tr>';
    $row .= '<td class="version-title">'. l(t('View details of changes'), 'admin/reports/hacked/' . $project['short_name']) ."</td>\n";
    $row .= '</tr>';

    $row .= '</table>';
    $row .= "</div>\n";

    /*
    if (isset($project['recommended'])) {
      if ($project['status'] != UPDATE_CURRENT || $project['existing_version'] !== $project['recommended']) {

        // First, figure out what to recommend.
        // If there's only 1 security update and it has the same version we're
        // recommending, give it the same CSS class as if it was recommended,
        // but don't print out a separate "Recommended" line for this project.
        if (!empty($project['security updates']) && count($project['security updates']) == 1 && $project['security updates'][0]['version'] === $project['recommended']) {
          $security_class = ' version-recommended version-recommended-strong';
        }
        else {
          $security_class = '';
          $version_class = 'version-recommended';
          // Apply an extra class if we're displaying both a recommended
          // version and anything else for an extra visual hint.
          if ($project['recommended'] !== $project['latest_version']
              || !empty($project['also'])
              || ($project['install_type'] == 'dev'
                 && isset($project['dev_version'])
                 && $project['latest_version'] !== $project['dev_version']
                 && $project['recommended'] !== $project['dev_version'])
              || (isset($project['security updates'][0])
                 && $project['recommended'] !== $project['security updates'][0])
              ) {
            $version_class .= ' version-recommended-strong';
          }
          $row .= theme('update_version', $project['releases'][$project['recommended']], t('Recommended version:'), $version_class);
        }

        // Now, print any security updates.
        if (!empty($project['security updates'])) {
          foreach ($project['security updates'] as $security_update) {
            $row .= theme('update_version', $security_update, t('Security update:'), 'version-security'. $security_class);
          }
        }
      }

      if ($project['recommended'] !== $project['latest_version']) {
        $row .= theme('update_version', $project['releases'][$project['latest_version']], t('Latest version:'), 'version-latest');
      }
      if ($project['install_type'] == 'dev'
          && $project['status'] != UPDATE_CURRENT
          && isset($project['dev_version'])
          && $project['recommended'] !== $project['dev_version']) {
        $row .= theme('update_version', $project['releases'][$project['dev_version']], t('Development version:'), 'version-latest');
      }
    }

    if (isset($project['also'])) {
      foreach ($project['also'] as $also) {
        $row .= theme('update_version', $project['releases'][$also], t('Also available:'), 'version-also-available');
      }
    }

    $row .= "</div>\n"; // versions div.
    */

    $row .= "<div class=\"info\">\n";
    if (!empty($project['extra'])) {
      $row .= '<div class="extra">' . "\n";
      foreach ($project['extra'] as $key => $value) {
        $row .= '<div class="' . $value['class'] . '">';
        $row .= check_plain($value['label']) . ': ';
        $row .= theme('placeholder', $value['data']);
        $row .= "</div>\n";
      }
      $row .= "</div>\n";  // extra div.
    }

    $row .= '<div class="includes">';
    sort($project['includes']);
    $row .= t('Includes: %includes', array('%includes' => implode(', ', $project['includes'])));
    $row .= "</div>\n";

    $row .= "</div>\n"; // info div.

    if (!isset($rows[$project['project_type']])) {
      $rows[$project['project_type']] = array();
    }
    $rows[$project['project_type']][] = array(
      'class' => $class,
      'data' => array($row),
    );
  }

  $project_types = array(
    'core' => t('Drupal core'),
    'module' => t('Modules'),
    'theme' => t('Themes'),
    'disabled-module' => t('Disabled modules'),
    'disabled-theme' => t('Disabled themes'),
  );
  foreach ($project_types as $type_name => $type_label) {
    if (!empty($rows[$type_name])) {
      $output .= "\n<h3>" . $type_label . "</h3>\n";
      $output .= theme('table', $header, $rows[$type_name], array('class' => 'update'));
    }
  }
  drupal_add_css(drupal_get_path('module', 'update') . '/update.css');
  return $output;
}
